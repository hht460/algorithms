1、 >>表示带符号右移； >>>无符号右移， 左边空出的位以0填充 
	5 >> 2 相当于 5除于2的平方，等于1 ，>>> 表示无符号 右移，高位用0 填充，0001 右移两位 0000

2、
	实例方法可以对当前对象的实例变量进行操作，也可以对类变量进行操作，但类方法不能访问实例变量。实例方法必须由实例对象来调用，而类方法除了可由实例对象调用外，还可以由类名直接调用。
	另外，在类方法中不能使用 this 或 super。 关于类方法的使用，有如下一些限制：
	1 在类方法中不能引用对象变量。
	2 在类方法中不能使用super、this关键字。
	3 类方法不能调用类中的对象方法。
	与类方法相比，实例方法几乎没有什么限制：
	1 实例方法可以引用对象变量（这是显然的），也可以引用类变量。
	2 实例方法中可以使用super、this关键字。
	3 实例方法中可以调用类方法。 

3、
	（1）：“在Java里面参数传递都是按值传递”这句话的意思是：
		按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。 
	（2）：在Java里面只有基本类型和按照下面这种定义方式的String是按值传递，其它的都是按引用传递。
		就是直接使用双引号定义字符串方式：String str = “Java私塾”;

4、
	public class Test {
    static int x=10;
    static {x+=5;}
    public static void main(String[] args) //4
        {
        System.out.println("x="+x);
    }
    static{x/=3;};
	}//9
	执行结束： x=5
		执行这个类的 main方法，会导致类进行加载，而类加载的属性如下
	 1、虚拟机在首次加载Java类时，会对静态初始化块、静态成员变量、静态方法进行一次初始化。
		我们不要去纠结这里的顺序，一般来说我们只需要知道，静态方法一般在最后。
	 2、只有在调用new方法时才会创建类的实例
	 3、类实例创建过程：按照父子继承关系进行初始化，首先执行父类的初始化块部分，然后是父类的构造方法；
		再执行本类继承的子类的初始化块，最后是子类的构造方法
	 4、类实例销毁时候，首先销毁子类部分，再销毁父类部分 
 
 5、
	public class NameList
	{
    private List names = new ArrayList();
    public synchronized void add(String name)
    {
        names.add(name);
    }
    public synchronized void printAll()     {
        for (int i = 0; i < names.size(); i++)
        {
            System.out.print(names.get(i) + ””);
        }
    }
 
    public static void main(String[]args)
    {
        final NameList sl = new NameList();
        for (int i = 0; i < 2; i++)
        {
            new Thread()
            {
                public void run()
                {
                    sl.add(“A”);
                    sl.add(“B”);
                    sl.add(“C”);
                    sl.printAll();
                }
            } .start();
        }
    }
	}
		The code may rum with output “A B C A B C A B C “, then exit.
		The code may ruin with output “A B C A A B C A B C “, then exit.
	
	在每个线程中都是顺序执行的，所以sl.printAll();必须在前三句执行之后执行，也就是输出的内容必有ABC。
	而线程之间是穿插执行的，所以一个线程执行 sl.printAll();之前可能有另一个线程执行了前三句的前几句。
	E答案相当于线程1顺序执行完然后线程2顺序执行完。
	G答案则是线程1执行完前三句add之后线程2插一脚执行了一句add然后线程1再执行 sl.printAll();输出ABCA。
	接着线程2顺序执行完输出ABCABC
	输出加起来即为ABCAABCABC。

6、	
	方法的重写（override）两同两小一大原则：
		方法名相同，参数类型相同
		子类返回类型小于等于父类方法返回类型，
		子类抛出异常小于等于父类方法抛出异常，
		子类访问权限大于等于父类方法访问权限。

7、
	构造方法是一种特殊的方法，具有以下特点。
	（1）构造方法的方法名必须与类名相同。
	（2）构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。
	（3）构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。
	（4）一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。
	（5）构造方法可以重载，以参数的个数，类型，顺序。

8、下面有关forward和redirect的描述：
		解释一：
		1.从地址栏显示来说
			forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
			redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.
		2.从数据共享来说
			forward:转发页面和转发到的页面可以共享request里面的数据.
			redirect:不能共享数据.
		3.从运用地方来说
			forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
			redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.
		4.从效率来说
			forward:高.
			redirect:低.
		
		解释二：
		request的forward和response的redirect
			1.redirect地址栏变化，forward发生在服务器端内部从而导致浏览器不知道响应资源来自哪里
			2.redirect可以重定向到同一个站点上的其他应用程序中的资源，forward 只能将请求 转发给同一个WEB应用中的组件
			3.redirect默认是302码，包含两次请求和两次响应
			4.redirect效率较低
		
		解释三：
		1) redirect 方式 
			response.sendRedirect("/a.jsp"); 
			页面的路径是相对路径。sendRedirect可以将页面跳转到任何页面，不一定局限于本web应用中，如： 
			response.sendRedirect("http://www.ycul.com"); 
			跳转后浏览器地址栏变化。 
			这种方式要传值出去的话，只能在url中带parameter或者放在session中，无法使用request.setAttribute来传递。 

		2) forward方式 
			RequestDispatcher dispatcher = request.getRequestDispatcher("/a.jsp"); 
			dispatcher .forward(request, response); 
			页面的路径是相对路径。forward方式只能跳转到本web应用中的页面上。 
			跳转后浏览器地址栏不会变化。 
			使用这种方式跳转，传值可以使用三种方法：url中带parameter，session，request.setAttribute 

第三次
1、下列Java代码中的变量a、b、c分别在内存的____存储区存放。
	常量区：未经 new 的常量
	堆区：成员变量的引用，new 出来的变量
	栈区：局部变量的引用 
	classA{
	 
		privateString a = “aa”; // a 为成员变量的引用，   在堆区， “aa”为未经 new 的常量，在常量区
	 
		publicboolean methodB() {
			String b = “bb”; // b 为局部变量的引用，      在栈区， “bb”为未经 new 的常量，在常量区
			final String c = “cc”; // c 为局部变量的引用，在栈区， “cc”为未经 new 的常量，在常量区
		}
	}
	
2、子类A继承父类B, A a = new A(); 
	则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？
答：当实例化子类对象时，首先要加载父类的class文件进内存，静态代码块是随着类的创建而执行，
	所以父类静态代码块最先被执行，子类class文件再被加载，同理静态代码块被先执行；
	实例化子类对象要先调用父类的构造方法，而调用父类构造方法前会先执行父类的非静态代码块 
	
	会先执行静态代码块，因为静态代码块是类级别的，是在创建对象之前就执行的。
	因为子类继承了父类，所以父类的静态代码块会先执行，接着执行子类的静态代码块。
    因为构造函数可能要给动态代码块的一些成员变量赋值，所以必须在这之前先执行动态代码块，
	要不然构造函数会出现相关的成员属性无定义。
	所以会先执行动态代码块，在执行构造函数。一般先按父类的执行，再按子类的执行。